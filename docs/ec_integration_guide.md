# Overview

This document covers details on how to build your own SP (Secure
Partition) and integrate it into a build with Hafnium support. It also
covers on how to modify ACPI and test calls from windows both through
ffadrv.sys interface or through ACPI.

## Creating a Secure Partition

There are three main parts to create and using a SP: generate the image,
link the image into your firmware volume and loading and running the SP.
We will cover each of these with examples of how to do this for a sample
QEMU image.

### Generating SP Image

The SP image is generated in RUST and is compromised of two main pieces:
  - FFA crate
  - Haf-ec-service

The FFA crate implements the FFA specific packet handling and
notifications. The actual EC services and final binary are generated by
Haf-ec-service.

You will first need recent version of RUST compiler installed.
Instructions here were tested using on top of WSL Ubuntu image. See
[rustup.rs - The Rust toolchain installer](https://rustup.rs/)

Unzip your ffa and haf-ec-service images and make sure you can build the
sample code:
```
  cargo build
  
  cargo xtask build
  
  Finished \`dev\` profile \[optimized + debuginfo\] target(s) in 0.19s
  Running \`target/debug/xtask build\`
  Compiling ec-sp v0.1.0 (haf-ec-service/ec-sp)
  Finished \`dev\` profile \[optimized + debuginfo\] target(s) in 0.33s
```

### Modifying SP Image

If you are rebuilding the ffa crate locally you will want to modify your
Cargo.toml image to pick up your local ffa crate.

```
[patch.crates-io]
#ffa = { git = "https://github.com/OpenDevicePartnership/ffa" }
ffa = { path = "/home/…/ffa" }
```

You will need to change your memory layout to match the memory layout
defined by UEFI where you have reserved memory for your secure
partitions. To modify the memory layout change ec-sp\\memory.x.

```
MEMORY
{
  FLASH (rx) : ORIGIN = 0x20410000, LENGTH = 0x40000
  DRAM (rwx) : ORIGIN = 0x20500000, LENGTH = 0x100000
}
```

The program starts running in start.s and jumps to main_sp in main.rs.
If you need to do some platform specific configuration you change change
in start.s and add custom exception handlers in exception.rs. We use the
CONSOLE_LOG64 for println implementation and debugging.

The sample code has a stub implementation for fw_mgmt and handles basic
notification events.

The main message handling loop is in main_sp() and calls into
ffa_msg_handler where the rest of the services can be implemented and
OEM services can be added.

### Defining Contents of SP

The details describing each SP are defined in the corresponding DTS
file. Each service ID is listed under the uuid section and a unique ID
must be specified for the SP in id. The load-address, entrypoint-offset,
image-size and memory-regions must be updated to match the values
provided when compiling the SP. Also make sure the flags for
messaging-method are set correctly to allow receiving of messages.
ns-interrupts-action and notification-support must be set to send
notifications to the non-secure world.

```
{
    /*
    * EC Service partition handles the following UUID'S
    * Notification UUID B510B3A3-59F6-4054-BA7A-FF2EB1EAC765
    * EC_SVC_MANAGEMENT 330c1273-fde5-4757-9819-5b6539037502
    * EC_SVC_POWER 7157addf-2fbe-4c63-ae95-efac16e3b01c
    * EC_SVC_BATTERY 25cb5207-ac36-427d-aaef-3aa78877d27e
    * EC_SVC_THERMAL 31f56da7-593c-4d72-a4b3-8fc7171ac073
    */
    compatible = "arm,ffa-manifest-1.0";
    description = "EC Services";
    ffa-version = <0x00010002>; /* 31:16 - Major, 15:0 - Minor */
    uuid = <0xB510B3A3 0x59F64054 0xBA7AFF2E 0xB1EAC765>,
           <0x330c1273 0xfde54757 0x98195b65 0x39037502>,
           <0x7157addf 0x2fbe4c63 0xae95efac 0x16e3b01c>;
    id = <0x8003>;
    execution-ctx-count = <1>;
    exception-level = <MODE_SEL1>; /* SEL1*/
    execution-state = <0>; /* AArch64*/
    load-address = <0x0 0x20400000>;
    entrypoint-offset = <0x10000>;
    image-size = <0x0 0x50000>;
    xlat-granule = <0>; /* 4KiB */
    boot-order = <2>;
    messaging-method = <0x603>; /* Direct request/response req2/rsp2 supported. */
    ns-interrupts-action = <2>; /* Non-secure interrupt is signaled */
    notification-support; /* Support receipt of notifications. */
    gp-register-num = <0>;
    
    boot-info {
      compatible = "arm,ffa-manifest-boot-info";
      ffa_manifest;
    };

    memory-regions {
      compatible = "arm,ffa-manifest-memory-regions";
      // Heap used by RUST code in SP
      heap {
        description = "heap";
        base-address = <0x0 0x20500000>;
        pages-count = <0x100>; /* 1MB of Heap space */
        attributes = <SECURE_RW>;
      };
    };
};
```

### Adding SP to Firmware Volume

All the secure partition images get linked into your FIP image. These
contents are determined by your sp_layout.json file while building
Hafnium. Make sure to export SP_LAYOUT_FILE=\<location
to\>\\sp_layout.json as part of the build. You should leave the entry
to point to your stmm image and then add a new SP entry for ec-sp.

```
{
    "stmm": {
        "image": {
            "file": mu_tiano_platforms/Build/QemuSbsaPkg/DEBUG_GCC5/FV/BL32_AP_MM.fd",
            "offset": "0x2000"
        },
        "pm": {
            "file": mu_tiano_platforms/Platforms/QemuSbsaPkg/fdts/qemu_sbsa_stmm_config.dts",
            "offset": "0x1000"
        },
        "uuid": "eaba83d8-baaf-4eaf-8144-f7fdcbe544a7",
        "owner": "Plat"
    },
    "ec-sp": {
        "image": {
            "file": "haf-ec-service/target/aarch64-unknown-none-softfloat/debug/ec-sp.bin",
            "offset": "0x10000"
        },
        "pm": {
            "file": "mu_tiano_platforms/Platforms/QemuSbsaPkg/fdts/ec_sp.dts",
            "offset": "0x1000"
        },
        "uuid": "8064A10B-9A26-4DF8-9629-024B64058B4F",
        "owner": "Plat"
    }
}
```

You will need to regenerate a unique UUID that defines the SP itself,
not the services. Point to your location of the DTS file and BIN files
for your SP.

### 

### Loading the SP During boot

Update the section for the vm you created or add a new one if you added
one. You must update both the manifest and fw config

mu_tiano_platforms/Silicon/Arm/TFA/plat/qemu/qemu_sbsa/fdts/qemu_sbsa_spmc_sp_manifest.dts

```
  /* EC Services */
  vm2 {
    is_ffa_partition;
    load_address = <0x0 0x20400000>;
    debug_name = "ec";
    vcpu_count = <1>;
    mem_size = <0x50000>;
  };
```

The actual loading of the partition is controlled in

mu_tiano_platforms/Silicon/Arm/TFA/plat/qemu/qemu_sbsa/fdts/qemu_sbsa_tb_fw_config.dts

```
  ec-sp {
    uuid = "8064A10B-9A26-4DF8-9629-024B64058B4F";
    load-address = <0x20400000>;
    owner = "Plat";
  };
```

## Building Mu UEFI and Hafnium

Normally you would sync Hafnium and build on its own. Currently both HAF
and ATF have been added into the Mu UEFI drop.

This version of Hafnium depends on an older clang version 14.0.0. If you
install latest clang 18.1.0 it will fail because of mismatched processor
and target flags.

### Download Clang 

```
git clone mu_tiano_platforms --recursive
export GCC5_AARCH64_PREFIX=/usr/bin/aarch64-linux-gnu-
export
PATH="/home/.../clang+llvm-14.0.0-x86_64-linux-gnu-ubuntu-18.04/bin:$PATH"
```

### Compiling UEFI with SP

You will need to update your PlatformBuild.py to point to your SP image.
Currently the sp_layout.json is created in the python file, this will
be moved externally

/mu_tiano_platforms/Platforms/QemuSbsaPkg/PlatformBuild.py


### Setting Up Shared Memory

As part of the ec-test-app there is a UEFI folder which includes sample
of how to map a shared memory buffer.

ec-test-app\\uefi\\Platforms\\QemuSbsaPkg\\SbsaQemuPlatformDxe\\SbsaQemuPlatformDxe.c

All the memory address definitions for the carveouts are in
SbsaQemuPlatform.h

The SBSAQEMU_RX/TX_BUFFER_BASE is only used for setup and then this
memory can be reclaimed. The SBSAQEMU_SHARED_MEM_BASE is the location
of memory that is marked as reserved and will persist that both the OS
and SP can access.

Now you are ready to build UEFI + TFA + Hafnium and link your SP you
previously built

```
stuart_setup -c Platforms/QemuSbsaPkg/PlatformBuild.py
TOOL_CHAIN_TAG=GCC5
stuart_update -c Platforms/QemuSbsaPkg/PlatformBuild.py
TOOL_CHAIN_TAG=GCC5
stuart_build -c Platforms/QemuSbsaPkg/PlatformBuild.py
TOOL_CHAIN_TAG=GCC5
```

### Running Windows Image and Testing SP

```
stuart_build -c Platforms/QemuSbsaPkg/PlatformBuild.py
TOOL_CHAIN_TAG=GCC5 --FlashOnly
```

Note if you have errors you may need to install missing packages listed
by the build system, follow messages accordingly.

If all goes well on your serial output it should boot all the way to
UEFI shell. To make sure you are running Hafnium and your SP started
successfully there are some messages you can look for in your serial
logs.

```
SP 8002: Hello from EL1
SP 8002: FFA Version: 1.2
SP 8002: Entering FFA message loop
INFO: Initialized VM: 0x8002, boot_order: 2
```